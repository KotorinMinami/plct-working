# Introduction

The RISC-V architecture has emerged as a prominent open-source instruction set architecture (ISA), rapidly gaining traction across a diverse range of applications, from embedded systems to high-performance computing. Its modular design and extensibility offer unprecedented levels of customization, which in turn necessitate the availability of robust and reliable formal specifications. These specifications are critical for ensuring the correct and interoperable implementation of RISC-V processors and tools. The Sail language has been adopted as a primary tool for formally specifying the semantics of RISC-V, including its complex memory model. Sail enables the generation of functionally correct emulators and facilitates formal verification, contributing to the overall reliability of RISC-V based systems.

However, the existing Sail-RISC-V memory model exhibits several limitations. Specifically, it lacks native support for 34-bit physical addresses within the RV32 specification, restricting its applicability in environments requiring larger physical address spaces. Furthermore, the current model conflates the concepts of physical and virtual memory, leading to ambiguities and introducing challenges for developers working with low-level system software, emulation tools, and formal verification. These inadequacies impede the rigorous analysis and development of RISC-V systems, particularly those where explicit control of physical memory is required. To address these limitations, we have undertaken a reconstruction of the Sail-RISC-V memory model. This reconstruction aims to achieve a clear separation between physical and virtual memory representations and to provide proper support for 34-bit physical addresses in the RV32 specification. This work is motivated by the need for a more precise and versatile model that aids in the development of reliable RISC-V implementations.

> 这是现状的详叙述以及spike的实现，属于是有关但不知道放哪好

 While Sail provides a robust framework for modeling RISC-V, it does have limitations, particularly in its default memory model implementation. Specifically, when no external memory read/write backends are specified, the Sail-RISC-V model interacts directly with a simulated memory provided by the Sail library. This interaction involves the construction of memory access requests, which are then dispatched to the appropriate module within the Sail framework. The request bodies and their processing mechanisms are entirely managed by the Sail library. However, Sail, being a type-safe language, enforces strict checks on the bit-width of addresses during data transfer. This restriction limits the address width to 32-bit or 64-bit, creating a limitation for models that need to handle physical address widths beyond these boundaries.

In contrast, the Sipke model employs a uint64_t type for storing and transferring physical addresses, regardless of the physical memory's actual bit-width. This approach provides greater flexibility in accommodating various physical address sizes. This method avoids type safety errors, and provides a more straightforward approach in cases where the physical address space is different from either 32 bits or 64 bits. This difference highlights a key limitation of the default Sail model when dealing with specific memory architectures with varying address widths. Our work builds upon these existing formalization efforts, aiming to overcome the identified limitations by reconstructing the Sail-RISC-V memory model to provide explicit support for 34-bit addresses and a clear separation between physical and virtual memory.

# Implement

Our approach to reconstructing the Sail-RISC-V memory model centers on the explicit separation of physical and virtual memory representations and the provision of native support for 34-bit physical addresses within RV32 contexts. 

To achieve this, we leveraged the newtype keyword within the Sail language. The newtype keyword provides a mechanism to define a new type that is distinct from an existing underlying type, even though they may have the same representation. We utilized this feature to clearly delineate the different address spaces within the Sail-RISC-V model. We analyzed the Sail-RISC-V model's code to identify instances where virtual memory addresses were used – specifically during Program Counter (PC) fetching, PC control flow operations, and data access operations. Similarly, we identified instances where physical memory addresses were used during communication with the memory model backends. For both virtual and physical memory addresses, we then introduced new, distinct types using newtype, such that a given type may now have an explicit meaning representing either the virtual or physical memory space. This allows for type-safe handling and prevents accidental use of one type where another is expected.

To address the limitation of existing upstream Sail models, which do not natively support 34-bit address lengths, we employed a mapping strategy that leverages the larger 64-bit address space. This approach involves mapping 34-bit physical addresses into a 64-bit representation. This mapping is achieved with minimal code changes, such that the original Sail-RISCV core model is kept as is as much as possible. Due to the significantly larger state space of 64-bit addresses compared to 34-bit addresses, this mapping poses no risk of address conflicts or overlaps during memory read and write operations. Specifically, we are able to implement a consistent mapping between 34-bit addresses to 64-bit addresses, such that any two different 34-bit addresses are also different in 64-bit representation. Furthermore, we avoid modifying existing code blocks and functions that are used for memory operations. Instead, the new types and the operations used on them are done transparently at the function boundaries by the address translation functions.

In practical terms, this approach involved the definition of new types for both physical and virtual addresses, ensuring these types could be easily used in existing Sail-RISCV code with minimal changes. The use of newtype allowed us to retain the type safety of Sail while representing the separation of address spaces and mapping 34-bit addresses to 64-bit addresses without loss of information. We then created functions that perform transparent address translation, at function boundaries, during memory access requests. These translations ensure that all the memory accesses respect the separation of physical and virtual addresses, with a consistent and correct mapping. By adopting this strategy, we were able to modify the Sail-RISC-V memory model with minimal invasiveness, all while introducing the necessary features to enable support for 34-bit physical addresses and a clear demarcation between physical and virtual memory domains.

# Evaluation

To rigorously validate the correctness and functionality of our reconstructed Sail-RISC-V memory model, we employed a comprehensive testing methodology centered around the RISC-V Compliance Framework (RISCOF). RISCOF is a widely adopted and well-established testing framework within the RISC-V community, providing a robust set of compliance tests that cover a wide range of RISC-V instructions and features, including those related to memory operations. Our testing process aimed to ascertain that the reconstructed memory model correctly handles address translation, memory accesses with the distinct physical and virtual address spaces, and the 34-bit address handling within the RV32 context.

The testing involved executing the RISCOF test suite against an emulator generated from our modified Sail-RISC-V specification. This approach ensured that our tests covered a variety of scenarios and edge cases relevant to the memory model. In the testing process, we ensured to select test cases from the RISCOF testing suite that are relevant to memory operations, making sure the tests would exercise both the virtual and physical memory address space as well as the address translation functionality. This approach allowed us to assess the core functionality of the memory model from the program's point of view. Each test case comprises a RISC-V program which executes memory access operations and a golden signature which describes the correct memory access results. We compare the output of our model against the golden signature to ensure correctness of the model.

We are pleased to report that the results of our testing process were overwhelmingly positive, with all relevant test cases from the RISCOF framework passing successfully against our reconstructed Sail model. This successful outcome demonstrates the accuracy and reliability of our approach in implementing the new memory model. The passing of RISCOF testing suite directly shows that the physical and virtual memory spaces are handled correctly, in a way that adheres to the RISC-V specification. This validation process also confirms that the mapping of 34-bit addresses to 64-bit address spaces and the address translation functionality works as intended. Additionally, this validation approach enables us to gain confidence in that our modifications correctly maintains the original RISC-V semantics, while providing more explicit support for memory operations.

Moreover, the successful integration with RISCOF provides a platform for further iterative testing. We are able to quickly add new tests to specifically target any issues we might discover with the new model in future development. This also means that our design approach is compatible with existing tool chains, making it easier for other developers to adopt our model. The rigorous validation process ensures that the reconstructed model is not only theoretically sound, but is also practically robust and useful for a wider range of RISC-V based development efforts.

# Discussion

The reconstruction of the Sail-RISC-V memory model, with its explicit separation of physical and virtual address spaces and native support for 34-bit physical addresses, has a significant impact on the overall understanding and formal analysis of RISC-V architectures. By clearly delineating between these two distinct address spaces, the new model provides a more accurate and unambiguous representation of memory-related behaviors. This enhanced clarity facilitates a more rigorous and straightforward analysis, thus fostering a deeper understanding of memory access and management at the low-level architecture of RISC-V implementations. This improvement is essential not only for researchers but also for developers, in general.

The reconstructed memory model also offers considerable benefits for tool developers, particularly those engaged in the creation of emulators, debuggers, and formal verification tools. The explicit representation of physical and virtual address spaces simplifies the implementation of these tools, especially concerning low-level memory management. It enables the construction of more reliable tools because the model more explicitly matches the hardware behavior. Furthermore, the incorporation of native support for 34-bit physical addresses removes a major hurdle for the verification of existing hardware, making it easier to develop and integrate into existing toolchains. This simplifies the development of such tools and increases the community’s confidence in the correctness of these RISC-V system tools, ultimately leading to faster development and deployment of more robust RISC-V systems.